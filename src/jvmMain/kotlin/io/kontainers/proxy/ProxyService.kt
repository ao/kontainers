package io.kontainers.proxy

import io.kontainers.model.ProxyRule
import io.kontainers.model.HealthCheck
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

/**
 * Service for managing proxy rules and generating Nginx configurations.
 */
class ProxyService(
    private val configPath: String = "/etc/nginx/nginx.conf",
    private val configDir: String = "/etc/nginx/conf.d"
) {
    // In-memory store for proxy rules (would be replaced with a database in production)
    private val proxyRules = ConcurrentHashMap<String, ProxyRule>()
    
    /**
     * Gets all proxy rules.
     */
    suspend fun getAllRules(): List<ProxyRule> = withContext(Dispatchers.IO) {
        proxyRules.values.toList()
    }
    
    /**
     * Gets a proxy rule by ID.
     */
    suspend fun getRule(id: String): ProxyRule? = withContext(Dispatchers.IO) {
        proxyRules[id]
    }
    
    /**
     * Creates a new proxy rule.
     */
    suspend fun createRule(rule: ProxyRule): ProxyRule = withContext(Dispatchers.IO) {
        val newRule = rule.copy(
            id = rule.id.ifEmpty { UUID.randomUUID().toString() },
            created = System.currentTimeMillis()
        )
        proxyRules[newRule.id] = newRule
        updateNginxConfig()
        newRule
    }
    
    /**
     * Updates an existing proxy rule.
     */
    suspend fun updateRule(id: String, rule: ProxyRule): ProxyRule? = withContext(Dispatchers.IO) {
        if (!proxyRules.containsKey(id)) return@withContext null
        
        val updatedRule = rule.copy(id = id)
        proxyRules[id] = updatedRule
        updateNginxConfig()
        updatedRule
    }
    
    /**
     * Deletes a proxy rule.
     */
    suspend fun deleteRule(id: String): Boolean = withContext(Dispatchers.IO) {
        val removed = proxyRules.remove(id) != null
        if (removed) {
            updateNginxConfig()
        }
        removed
    }
    
    /**
     * Enables or disables a proxy rule.
     */
    suspend fun setRuleEnabled(id: String, enabled: Boolean): ProxyRule? = withContext(Dispatchers.IO) {
        val rule = proxyRules[id] ?: return@withContext null
        val updatedRule = rule.copy(enabled = enabled)
        proxyRules[id] = updatedRule
        updateNginxConfig()
        updatedRule
    }
    
    /**
     * Updates the Nginx configuration based on the current proxy rules.
     */
    private suspend fun updateNginxConfig() = withContext(Dispatchers.IO) {
        try {
            // In a real implementation, this would generate and write Nginx config files
            // For now, we'll just simulate it
            val config = generateNginxConfig()
            
            // In a real implementation, we would write the config to a file
            // File(configPath).writeText(config)
            
            // In a real implementation, we would reload Nginx
            // ProcessBuilder("nginx", "-s", "reload").start().waitFor()
            
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Generates Nginx configuration based on the current proxy rules.
     */
    private fun generateNginxConfig(): String {
        return buildString {
            appendLine("# Generated by Kontainers")
            appendLine("events { worker_connections 1024; }")
            appendLine("http {")
            appendLine("    include /etc/nginx/mime.types;")
            appendLine("    default_type application/octet-stream;")
            appendLine("    sendfile on;")
            appendLine("    keepalive_timeout 65;")
            appendLine("    server_tokens off;")
            appendLine()
            
            // Generate server blocks for each enabled rule
            proxyRules.values.filter { it.enabled }.forEach { rule ->
                appendLine("    server {")
                appendLine("        listen ${if (rule.sslEnabled) "443 ssl" else "80"};")
                appendLine("        server_name ${rule.sourceHost};")
                
                if (rule.sslEnabled && rule.sslCertPath != null) {
                    appendLine("        ssl_certificate ${rule.sslCertPath};")
                    appendLine("        ssl_certificate_key ${rule.sslCertPath.replace(".crt", ".key")};")
                    appendLine("        ssl_protocols TLSv1.2 TLSv1.3;")
                    appendLine("        ssl_prefer_server_ciphers on;")
                }
                
                appendLine("        location ${rule.sourcePath} {")
                appendLine("            proxy_pass http://${rule.targetContainer}:${rule.targetPort};")
                appendLine("            proxy_set_header Host \${'$'}host;")
                appendLine("            proxy_set_header X-Real-IP \${'$'}remote_addr;")
                appendLine("            proxy_set_header X-Forwarded-For \${'$'}proxy_add_x_forwarded_for;")
                appendLine("            proxy_set_header X-Forwarded-Proto \${'$'}scheme;")
                
                // Add custom headers
                rule.headers.forEach { (key, value) ->
                    appendLine("            proxy_set_header $key $value;")
                }
                
                // Add health check if configured
                rule.healthCheck?.let { healthCheck ->
                    appendLine("            # Health check configuration")
                    appendLine("            health_check uri=${healthCheck.path} interval=${healthCheck.interval}s " +
                              "fails=${healthCheck.retries} passes=1 match=status;")
                    appendLine("            match status {")
                    appendLine("                status 200-399;")
                    appendLine("            }")
                }
                
                appendLine("        }")
                appendLine("    }")
                appendLine()
            }
            
            appendLine("}")
        }
    }
    
    /**
     * Tests a proxy rule configuration.
     */
    suspend fun testRule(rule: ProxyRule): Boolean = withContext(Dispatchers.IO) {
        try {
            // In a real implementation, this would test the connection to the target container
            // For now, we'll just simulate it
            true
        } catch (e: Exception) {
            false
        }
    }
}