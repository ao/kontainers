package io.kontainers.proxy

import io.kontainers.model.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.withContext
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.DumperOptions
import java.io.File
import java.net.HttpURLConnection
import java.net.URL
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption
import java.time.Duration
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit

/**
 * Service for managing proxy rules and generating Nginx configurations.
 */
class ProxyService(
    private val configPath: String = if (System.getProperty("dev.mode") == "true") "./tmp/nginx/nginx.conf" else "/etc/nginx/nginx.conf",
    private val configDir: String = if (System.getProperty("dev.mode") == "true") "./tmp/nginx/conf.d" else "/etc/nginx/conf.d",
    private val sslCertDir: String = if (System.getProperty("dev.mode") == "true") "./tmp/nginx/ssl" else "/etc/nginx/ssl",
    private val nginxTemplateDir: String = if (System.getProperty("dev.mode") == "true") "./tmp/nginx/templates" else "/etc/nginx/templates",
    private val maxTrafficDataPoints: Int = 1000,
    private val maxErrorEntries: Int = 1000,
    private val maxLogEntries: Int = 10000,
    private val cacheEnabled: Boolean = true,
    private val cacheTtl: Duration = Duration.ofMinutes(5)
) {
    // In-memory store for proxy rules (would be replaced with a database in production)
    private val proxyRules = ConcurrentHashMap<String, ProxyRule>()
    
    // In-memory store for traffic data (would be replaced with a time-series database in production)
    private val trafficData = ConcurrentHashMap<String, ConcurrentLinkedQueue<ProxyTrafficData>>()
    
    // In-memory store for errors (would be replaced with a database in production)
    private val proxyErrors = ConcurrentHashMap<String, ConcurrentLinkedQueue<ProxyError>>()
    
    // In-memory store for request/response logs (would be replaced with a database in production)
    private val requestLogs = ConcurrentHashMap<String, ConcurrentLinkedQueue<RequestResponseLog>>()
    
    // In-memory store for alert configurations (would be replaced with a database in production)
    private val alertConfigs = ConcurrentHashMap<String, ErrorAlertConfig>()
    
    // In-memory store for active alerts (would be replaced with a database in production)
    private val activeAlerts = ConcurrentHashMap<String, ErrorAlert>()
    
    // Cache for frequently accessed data
    private val rulesCache = ConcurrentHashMap<String, Pair<ProxyRule, Long>>()
    private val allRulesCache = ConcurrentHashMap<String, Pair<List<ProxyRule>, Long>>()
    private val certificatesCache = ConcurrentHashMap<String, Pair<List<String>, Long>>()
    private val templatesCache = ConcurrentHashMap<String, Pair<List<String>, Long>>()
    
    // Cache invalidation scheduler
    private val cacheCleanupScheduler: ScheduledExecutorService = Executors.newSingleThreadScheduledExecutor()
    
    // Shared flow for real-time traffic updates
    private val _trafficUpdates = MutableSharedFlow<ProxyTrafficData>(replay = 0, extraBufferCapacity = 100)
    val trafficUpdates: Flow<ProxyTrafficData> = _trafficUpdates.asSharedFlow()
    
    // Shared flow for real-time error updates
    private val _errorUpdates = MutableSharedFlow<ProxyError>(replay = 0, extraBufferCapacity = 100)
    val errorUpdates: Flow<ProxyError> = _errorUpdates.asSharedFlow()
    
    // Shared flow for real-time log updates
    private val _logUpdates = MutableSharedFlow<RequestResponseLog>(replay = 0, extraBufferCapacity = 100)
    val logUpdates: Flow<RequestResponseLog> = _logUpdates.asSharedFlow()
    
    // Shared flow for real-time alert updates
    private val _alertUpdates = MutableSharedFlow<ErrorAlert>(replay = 0, extraBufferCapacity = 100)
    val alertUpdates: Flow<ErrorAlert> = _alertUpdates.asSharedFlow()
    
    // Default Nginx template
    private val defaultNginxTemplate = """
        # Generated by Kontainers
        events { worker_connections 1024; }
        http {
            include /etc/nginx/mime.types;
            default_type application/octet-stream;
            sendfile on;
            keepalive_timeout 65;
            server_tokens off;
            
            # Proxy server configurations
            {{SERVER_BLOCKS}}
        }
    """.trimIndent()
    
    init {
        // Ensure directories exist
        File(configDir).mkdirs()
        File(sslCertDir).mkdirs()
        File(nginxTemplateDir).mkdirs()
        
        // Create default template if it doesn't exist
        val defaultTemplatePath = "$nginxTemplateDir/default.conf.template"
        if (!File(defaultTemplatePath).exists()) {
            File(defaultTemplatePath).writeText(defaultNginxTemplate)
        }
        
        // Schedule cache cleanup
        if (cacheEnabled) {
            cacheCleanupScheduler.scheduleAtFixedRate(
                { cleanupCache() },
                cacheTtl.toMinutes(),
                cacheTtl.toMinutes(),
                TimeUnit.MINUTES
            )
        }
    }
    
    /**
     * Cleans up expired cache entries.
     */
    private fun cleanupCache() {
        val now = System.currentTimeMillis()
        val expiryTime = now - cacheTtl.toMillis()
        
        // Clean up rules cache
        rulesCache.entries.removeIf { (_, value) -> value.second < expiryTime }
        
        // Clean up all rules cache
        allRulesCache.entries.removeIf { (_, value) -> value.second < expiryTime }
        
        // Clean up certificates cache
        certificatesCache.entries.removeIf { (_, value) -> value.second < expiryTime }
        
        // Clean up templates cache
        templatesCache.entries.removeIf { (_, value) -> value.second < expiryTime }
    }
    
    /**
     * Gets all proxy rules.
     */
    suspend fun getAllRules(): List<ProxyRule> = withContext(Dispatchers.IO) {
        if (cacheEnabled) {
            val cacheKey = "all_rules"
            val cachedValue = allRulesCache[cacheKey]
            
            if (cachedValue != null && System.currentTimeMillis() - cachedValue.second < cacheTtl.toMillis()) {
                return@withContext cachedValue.first
            }
            
            val rules = proxyRules.values.toList()
            allRulesCache[cacheKey] = Pair(rules, System.currentTimeMillis())
            rules
        } else {
            proxyRules.values.toList()
        }
    }
    
    /**
     * Gets a proxy rule by ID.
     */
    suspend fun getRule(id: String): ProxyRule? = withContext(Dispatchers.IO) {
        if (cacheEnabled) {
            val cachedValue = rulesCache[id]
            
            if (cachedValue != null && System.currentTimeMillis() - cachedValue.second < cacheTtl.toMillis()) {
                return@withContext cachedValue.first
            }
            
            val rule = proxyRules[id]
            if (rule != null) {
                rulesCache[id] = Pair(rule, System.currentTimeMillis())
            }
            rule
        } else {
            proxyRules[id]
        }
    }
    
    /**
     * Creates a new proxy rule.
     */
    suspend fun createRule(rule: ProxyRule): ProxyRule = withContext(Dispatchers.IO) {
        val newRule = rule.copy(
            id = rule.id.ifEmpty { UUID.randomUUID().toString() },
            created = System.currentTimeMillis()
        )
        proxyRules[newRule.id] = newRule
        
        // Invalidate cache
        if (cacheEnabled) {
            rulesCache.remove(newRule.id)
            allRulesCache.clear()
        }
        
        updateNginxConfig()
        newRule
    }
    
    /**
     * Updates an existing proxy rule.
     */
    suspend fun updateRule(id: String, rule: ProxyRule): ProxyRule? = withContext(Dispatchers.IO) {
        if (!proxyRules.containsKey(id)) return@withContext null
        
        val updatedRule = rule.copy(id = id)
        proxyRules[id] = updatedRule
        
        // Invalidate cache
        if (cacheEnabled) {
            rulesCache.remove(id)
            allRulesCache.clear()
        }
        
        updateNginxConfig()
        updatedRule
    }
    
    /**
     * Deletes a proxy rule.
     */
    suspend fun deleteRule(id: String): Boolean = withContext(Dispatchers.IO) {
        val removed = proxyRules.remove(id) != null
        if (removed) {
            // Invalidate cache
            if (cacheEnabled) {
                rulesCache.remove(id)
                allRulesCache.clear()
            }
            
            updateNginxConfig()
        }
        removed
    }
    
    /**
     * Enables or disables a proxy rule.
     */
    suspend fun setRuleEnabled(id: String, enabled: Boolean): ProxyRule? = withContext(Dispatchers.IO) {
        val rule = proxyRules[id] ?: return@withContext null
        val updatedRule = rule.copy(enabled = enabled)
        proxyRules[id] = updatedRule
        
        // Invalidate cache
        if (cacheEnabled) {
            rulesCache.remove(id)
            allRulesCache.clear()
        }
        
        updateNginxConfig()
        updatedRule
    }
    
    /**
     * Updates the Nginx configuration based on the current proxy rules.
     */
    private suspend fun updateNginxConfig() = withContext(Dispatchers.IO) {
        try {
            // In a real implementation, this would generate and write Nginx config files
            // For now, we'll just simulate it
            val config = generateNginxConfig()
            
            // In a real implementation, we would write the config to a file
            // File(configPath).writeText(config)
            
            // In a real implementation, we would reload Nginx
            // ProcessBuilder("nginx", "-s", "reload").start().waitFor()
            
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Generates Nginx configuration based on the current proxy rules.
     */
    private fun generateNginxConfig(): String {
        val serverBlocks = buildString {
            // Generate server blocks for each enabled rule
            proxyRules.values.filter { it.enabled }.forEach { rule ->
                // Use custom Nginx config if provided
                if (!rule.customNginxConfig.isNullOrBlank()) {
                    append(rule.customNginxConfig)
                    appendLine()
                    return@forEach
                }
                
                appendLine("    server {")
                appendLine("        listen ${if (rule.sslEnabled) "443 ssl" else "80"};")
                appendLine("        server_name ${rule.sourceHost};")
                
                // SSL configuration
                if (rule.sslEnabled) {
                    if (rule.sslCertPath != null) {
                        appendLine("        ssl_certificate ${rule.sslCertPath};")
                        appendLine("        ssl_certificate_key ${rule.sslKeyPath ?: rule.sslCertPath.replace(".crt", ".key")};")
                        appendLine("        ssl_protocols TLSv1.2 TLSv1.3;")
                        appendLine("        ssl_prefer_server_ciphers on;")
                        appendLine("        ssl_session_cache shared:SSL:10m;")
                        appendLine("        ssl_session_timeout 10m;")
                    }
                }
                
                // Advanced configuration
                rule.advancedConfig?.let { config ->
                    if (config.clientMaxBodySize != null) {
                        appendLine("        client_max_body_size ${config.clientMaxBodySize};")
                    }
                    
                    // CORS configuration
                    if (config.corsEnabled) {
                        appendLine("        # CORS configuration")
                        appendLine("        add_header 'Access-Control-Allow-Origin' '${config.corsAllowOrigin ?: "*"}' always;")
                        appendLine("        add_header 'Access-Control-Allow-Methods' '${config.corsAllowMethods ?: "GET, POST, OPTIONS"}' always;")
                        appendLine("        add_header 'Access-Control-Allow-Headers' '${config.corsAllowHeaders ?: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range"}' always;")
                        if (config.corsAllowCredentials) {
                            appendLine("        add_header 'Access-Control-Allow-Credentials' 'true' always;")
                        }
                        
                        // OPTIONS preflight request handling
                        appendLine("        if (\${'$'}request_method = 'OPTIONS') {")
                        appendLine("            add_header 'Access-Control-Allow-Origin' '${config.corsAllowOrigin ?: "*"}';")
                        appendLine("            add_header 'Access-Control-Allow-Methods' '${config.corsAllowMethods ?: "GET, POST, OPTIONS"}';")
                        appendLine("            add_header 'Access-Control-Allow-Headers' '${config.corsAllowHeaders ?: "DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range"}';")
                        if (config.corsAllowCredentials) {
                            appendLine("            add_header 'Access-Control-Allow-Credentials' 'true';")
                        }
                        appendLine("            add_header 'Access-Control-Max-Age' 1728000;")
                        appendLine("            add_header 'Content-Type' 'text/plain; charset=utf-8';")
                        appendLine("            add_header 'Content-Length' 0;")
                        appendLine("            return 204;")
                        appendLine("        }")
                    }
                    
                    // Rate limiting
                    config.rateLimit?.let { rateLimit ->
                        appendLine("        # Rate limiting")
                        appendLine("        limit_req_zone \${'$'}binary_remote_addr zone=limit_${rule.id}:10m rate=${rateLimit.requestsPerSecond}r/s;")
                        val nodelay = if (rateLimit.nodelay) " nodelay" else ""
                        appendLine("        limit_req zone=limit_${rule.id} burst=${rateLimit.burstSize}$nodelay;")
                    }
                    
                    // URL rewrite rules
                    if (config.rewriteRules.isNotEmpty()) {
                        appendLine("        # URL rewrite rules")
                        config.rewriteRules.forEach { rewriteRule ->
                            appendLine("        rewrite ${rewriteRule.pattern} ${rewriteRule.replacement} ${rewriteRule.flag};")
                        }
                    }
                }
                
                // Location block
                appendLine("        location ${rule.sourcePath} {")
                
                // Load balancing configuration
                if (rule.loadBalancing != null && rule.loadBalancing.targets.isNotEmpty()) {
                    val method = when (rule.loadBalancing.method) {
                        LoadBalancingMethod.ROUND_ROBIN -> ""
                        LoadBalancingMethod.LEAST_CONN -> "least_conn"
                        LoadBalancingMethod.IP_HASH -> "ip_hash"
                        LoadBalancingMethod.RANDOM -> "random"
                    }
                    
                    appendLine("            # Load balancing configuration")
                    appendLine("            upstream backend_${rule.id} {")
                    if (method.isNotEmpty()) {
                        appendLine("                $method;")
                    }
                    
                    // Sticky sessions
                    if (rule.loadBalancing.sticky && rule.loadBalancing.cookieName != null) {
                        val expiry = if (rule.loadBalancing.cookieExpiry != null) " expires=${rule.loadBalancing.cookieExpiry}h" else ""
                        appendLine("                sticky cookie ${rule.loadBalancing.cookieName}$expiry;")
                    }
                    
                    // Targets
                    rule.loadBalancing.targets.forEach { target ->
                        appendLine("                server ${target.container}:${target.port} weight=${target.weight};")
                    }
                    appendLine("            }")
                    
                    appendLine("            proxy_pass http://backend_${rule.id};")
                } else {
                    // Single target
                    appendLine("            proxy_pass http://${rule.targetContainer}:${rule.targetPort};")
                }
                
                // Advanced proxy settings
                rule.advancedConfig?.let { config ->
                    appendLine("            proxy_connect_timeout ${config.proxyConnectTimeout}s;")
                    appendLine("            proxy_send_timeout ${config.proxySendTimeout}s;")
                    appendLine("            proxy_read_timeout ${config.proxyReadTimeout}s;")
                    
                    if (config.proxyBufferSize != null) {
                        appendLine("            proxy_buffer_size ${config.proxyBufferSize};")
                    }
                    if (config.proxyBuffers != null) {
                        appendLine("            proxy_buffers ${config.proxyBuffers};")
                    }
                    if (config.proxyBusyBuffersSize != null) {
                        appendLine("            proxy_busy_buffers_size ${config.proxyBusyBuffersSize};")
                    }
                    
                    // Cache configuration
                    if (config.cacheEnabled && config.cacheDuration != null) {
                        appendLine("            # Cache configuration")
                        appendLine("            proxy_cache proxy_cache_${rule.id};")
                        appendLine("            proxy_cache_valid 200 ${config.cacheDuration};")
                        appendLine("            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;")
                        appendLine("            proxy_cache_lock on;")
                    }
                }
                
                // Standard headers
                appendLine("            proxy_set_header Host \${'$'}host;")
                appendLine("            proxy_set_header X-Real-IP \${'$'}remote_addr;")
                appendLine("            proxy_set_header X-Forwarded-For \${'$'}proxy_add_x_forwarded_for;")
                appendLine("            proxy_set_header X-Forwarded-Proto \${'$'}scheme;")
                
                // Request headers
                rule.headers.forEach { (key, value) ->
                    appendLine("            proxy_set_header $key $value;")
                }
                
                // Response headers
                rule.responseHeaders.forEach { (key, value) ->
                    appendLine("            add_header $key $value always;")
                }
                
                // Health check configuration
                rule.healthCheck?.let { healthCheck ->
                    appendLine("            # Health check configuration")
                    appendLine("            health_check uri=${healthCheck.path} interval=${healthCheck.interval}s " +
                              "timeout=${healthCheck.timeout}s fails=${healthCheck.retries} passes=1 match=status;")
                    appendLine("            match status {")
                    appendLine("                status ${healthCheck.successCodes};")
                    appendLine("            }")
                }
                
                appendLine("        }")
                appendLine("    }")
                appendLine()
            }
        }
        
        // Use default template or custom template
        return defaultNginxTemplate.replace("{{SERVER_BLOCKS}}", serverBlocks)
    }
    
    /**
     * Tests a proxy rule configuration.
     */
    suspend fun testRule(rule: ProxyRule): Boolean = withContext(Dispatchers.IO) {
        try {
            // Test connection to target container
            val targetUrl = "http://${rule.targetContainer}:${rule.targetPort}${rule.healthCheck?.path ?: "/"}"
            val connection = URL(targetUrl).openConnection() as HttpURLConnection
            connection.connectTimeout = 5000
            connection.readTimeout = 5000
            connection.requestMethod = "GET"
            
            val responseCode = connection.responseCode
            return@withContext responseCode in 200..399
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Uploads an SSL certificate.
     */
    suspend fun uploadCertificate(name: String, certContent: ByteArray, keyContent: ByteArray?): Boolean = withContext(Dispatchers.IO) {
        try {
            val certFile = File("$sslCertDir/$name.crt")
            Files.write(certFile.toPath(), certContent)
            
            if (keyContent != null) {
                val keyFile = File("$sslCertDir/$name.key")
                Files.write(keyFile.toPath(), keyContent)
            }
            
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Lists all SSL certificates.
     */
    suspend fun listCertificates(): List<String> = withContext(Dispatchers.IO) {
        try {
            if (cacheEnabled) {
                val cacheKey = "certificates"
                val cachedValue = certificatesCache[cacheKey]
                
                if (cachedValue != null && System.currentTimeMillis() - cachedValue.second < cacheTtl.toMillis()) {
                    return@withContext cachedValue.first
                }
                
                val certificates = File(sslCertDir).listFiles()
                    ?.filter { it.name.endsWith(".crt") }
                    ?.map { it.name.removeSuffix(".crt") }
                    ?: emptyList()
                
                certificatesCache[cacheKey] = Pair(certificates, System.currentTimeMillis())
                certificates
            } else {
                File(sslCertDir).listFiles()
                    ?.filter { it.name.endsWith(".crt") }
                    ?.map { it.name.removeSuffix(".crt") }
                    ?: emptyList()
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Deletes an SSL certificate.
     */
    suspend fun deleteCertificate(name: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val certFile = File("$sslCertDir/$name.crt")
            val keyFile = File("$sslCertDir/$name.key")
            
            var success = true
            if (certFile.exists()) {
                success = certFile.delete()
            }
            
            if (keyFile.exists()) {
                success = success && keyFile.delete()
            }
            
            // Invalidate cache
            if (cacheEnabled) {
                certificatesCache.clear()
            }
            
            success
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Gets custom Nginx templates.
     */
    suspend fun getTemplates(): List<String> = withContext(Dispatchers.IO) {
        try {
            if (cacheEnabled) {
                val cacheKey = "templates"
                val cachedValue = templatesCache[cacheKey]
                
                if (cachedValue != null && System.currentTimeMillis() - cachedValue.second < cacheTtl.toMillis()) {
                    return@withContext cachedValue.first
                }
                
                val templates = File(nginxTemplateDir).listFiles()
                    ?.filter { it.name.endsWith(".template") }
                    ?.map { it.name }
                    ?: emptyList()
                
                templatesCache[cacheKey] = Pair(templates, System.currentTimeMillis())
                templates
            } else {
                File(nginxTemplateDir).listFiles()
                    ?.filter { it.name.endsWith(".template") }
                    ?.map { it.name }
                    ?: emptyList()
            }
        } catch (e: Exception) {
            emptyList()
        }
    }
    
    /**
     * Gets a custom Nginx template.
     */
    suspend fun getTemplate(name: String): String? = withContext(Dispatchers.IO) {
        try {
            val file = File("$nginxTemplateDir/$name")
            if (file.exists()) {
                file.readText()
            } else {
                null
            }
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Saves a custom Nginx template.
     */
    suspend fun saveTemplate(name: String, content: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val file = File("$nginxTemplateDir/$name")
            file.writeText(content)
            
            // Invalidate cache
            if (cacheEnabled) {
                templatesCache.clear()
            }
            
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Deletes a custom Nginx template.
     */
    suspend fun deleteTemplate(name: String): Boolean = withContext(Dispatchers.IO) {
        try {
            val file = File("$nginxTemplateDir/$name")
            if (file.exists()) {
                val result = file.delete()
                
                // Invalidate cache
                if (result && cacheEnabled) {
                    templatesCache.clear()
                }
                
                result
            } else {
                false
            }
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Validates a proxy rule configuration.
     */
    suspend fun validateRule(rule: ProxyRule): Map<String, Any> = withContext(Dispatchers.IO) {
        val issues = mutableListOf<String>()
        
        // Check if source host is valid
        if (rule.sourceHost.isBlank()) {
            issues.add("Source host cannot be empty")
        }
        
        // Check if target container is valid
        if (rule.targetContainer.isBlank() && (rule.loadBalancing == null || rule.loadBalancing.targets.isEmpty())) {
            issues.add("Target container cannot be empty when load balancing is not configured")
        }
        
        // Check if SSL is properly configured
        if (rule.sslEnabled && rule.sslCertPath.isNullOrBlank()) {
            issues.add("SSL certificate path is required when SSL is enabled")
        }
        
        // Check if target port is valid
        if (rule.targetPort <= 0 && (rule.loadBalancing == null || rule.loadBalancing.targets.isEmpty())) {
            issues.add("Target port must be greater than 0")
        }
        
        // Check SSL configuration
        if (rule.sslEnabled && rule.sslCertPath.isNullOrBlank()) {
            issues.add("SSL certificate path is required when SSL is enabled")
        }
        
        // Check load balancing configuration
        if (rule.loadBalancing != null && rule.loadBalancing.targets.isEmpty()) {
            issues.add("Load balancing targets cannot be empty when load balancing is enabled")
        }
        
        // Check if sticky sessions are properly configured
        if (rule.loadBalancing?.sticky == true && rule.loadBalancing.cookieName.isNullOrBlank()) {
            issues.add("Cookie name is required for sticky sessions")
        }
        
        mapOf(
            "valid" to issues.isEmpty(),
            "issues" to issues
        )
    }
    
    /**
     * Records traffic data for a proxy rule.
     */
    suspend fun recordTrafficData(data: ProxyTrafficData) = withContext(Dispatchers.IO) {
        val queue = trafficData.computeIfAbsent(data.ruleId) { ConcurrentLinkedQueue() }
        
        // Add the new data point
        queue.add(data)
        
        // Trim the queue if it exceeds the maximum size
        while (queue.size > maxTrafficDataPoints) {
            queue.poll()
        }
        
        // Emit the data point to the shared flow
        _trafficUpdates.emit(data)
    }
    
    /**
     * Gets traffic data for a proxy rule.
     */
    suspend fun getTrafficData(ruleId: String, limit: Int = 100): List<ProxyTrafficData> = withContext(Dispatchers.IO) {
        val queue = trafficData[ruleId] ?: return@withContext emptyList()
        return@withContext queue.toList().takeLast(limit)
    }
    
    /**
     * Gets traffic data for all proxy rules.
     */
    suspend fun getAllTrafficData(limit: Int = 100): Map<String, List<ProxyTrafficData>> = withContext(Dispatchers.IO) {
        return@withContext trafficData.mapValues { (_, queue) -> queue.toList().takeLast(limit) }
    }
    
    /**
     * Gets a traffic summary for a proxy rule.
     */
    suspend fun getTrafficSummary(ruleId: String, period: String): ProxyTrafficSummary = withContext(Dispatchers.IO) {
        val queue = trafficData[ruleId] ?: return@withContext ProxyTrafficSummary(
            ruleId = ruleId,
            totalRequests = 0,
            totalResponses = 0,
            totalBytesReceived = 0,
            totalBytesSent = 0,
            avgResponseTime = 0.0,
            statusCodeDistribution = emptyMap(),
            requestMethodDistribution = emptyMap(),
            topClientIps = emptyList(),
            topUserAgents = emptyList(),
            topPaths = emptyList(),
            period = period
        )
        
        val now = System.currentTimeMillis()
        val timeWindow = when (period) {
            "last_hour" -> 60 * 60 * 1000L
            "last_day" -> 24 * 60 * 60 * 1000L
            "last_week" -> 7 * 24 * 60 * 60 * 1000L
            else -> 60 * 60 * 1000L // Default to last hour
        }
        
        val filteredData = queue.filter { now - it.timestamp <= timeWindow }
        
        if (filteredData.isEmpty()) {
            return@withContext ProxyTrafficSummary(
                ruleId = ruleId,
                totalRequests = 0,
                totalResponses = 0,
                totalBytesReceived = 0,
                totalBytesSent = 0,
                avgResponseTime = 0.0,
                statusCodeDistribution = emptyMap(),
                requestMethodDistribution = emptyMap(),
                topClientIps = emptyList(),
                topUserAgents = emptyList(),
                topPaths = emptyList(),
                period = period
            )
        }
        
        val totalRequests = filteredData.sumOf { it.requestCount }
        val totalResponses = filteredData.sumOf { it.responseCount }
        val totalBytesReceived = filteredData.sumOf { it.bytesReceived }
        val totalBytesSent = filteredData.sumOf { it.bytesSent }
        val avgResponseTime = filteredData.map { it.avgResponseTime }.average()
        
        // Aggregate status codes
        val statusCodeDistribution = filteredData
            .flatMap { it.statusCodes.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { it.value.sum() }
        
        // Aggregate request methods
        val requestMethodDistribution = filteredData
            .flatMap { it.requestMethods.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { it.value.sum() }
        
        // Aggregate client IPs
        val clientIpDistribution = filteredData
            .flatMap { it.clientIps.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { it.value.sum() }
            .toList()
            .sortedByDescending { it.second }
            .take(10)
        
        // Aggregate user agents
        val userAgentDistribution = filteredData
            .flatMap { it.userAgents.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { it.value.sum() }
            .toList()
            .sortedByDescending { it.second }
            .take(10)
        
        // Aggregate paths
        val pathDistribution = filteredData
            .flatMap { it.pathHits.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { it.value.sum() }
            .toList()
            .sortedByDescending { it.second }
            .take(10)
        
        return@withContext ProxyTrafficSummary(
            ruleId = ruleId,
            totalRequests = totalRequests,
            totalResponses = totalResponses,
            totalBytesReceived = totalBytesReceived,
            totalBytesSent = totalBytesSent,
            avgResponseTime = avgResponseTime,
            statusCodeDistribution = statusCodeDistribution,
            requestMethodDistribution = requestMethodDistribution,
            topClientIps = clientIpDistribution,
            topUserAgents = userAgentDistribution,
            topPaths = pathDistribution,
            period = period
        )
    }
    
    /**
     * Records an error for a proxy rule.
     */
    suspend fun recordError(error: ProxyError) = withContext(Dispatchers.IO) {
        val queue = proxyErrors.computeIfAbsent(error.ruleId) { ConcurrentLinkedQueue() }
        
        // Add the new error
        queue.add(error)
        
        // Trim the queue if it exceeds the maximum size
        while (queue.size > maxErrorEntries) {
            queue.poll()
        }
        
        // Emit the error to the shared flow
        _errorUpdates.emit(error)
        
        // Check if the error should trigger an alert
        checkErrorAlerts(error)
    }
    
    /**
     * Gets errors for a proxy rule.
     */
    suspend fun getErrors(ruleId: String, limit: Int = 100): List<ProxyError> = withContext(Dispatchers.IO) {
        val queue = proxyErrors[ruleId] ?: return@withContext emptyList()
        return@withContext queue.toList().takeLast(limit)
    }
    
    /**
     * Gets errors for all proxy rules.
     */
    suspend fun getAllErrors(limit: Int = 100): Map<String, List<ProxyError>> = withContext(Dispatchers.IO) {
        return@withContext proxyErrors.mapValues { (_, queue) -> queue.toList().takeLast(limit) }
    }
    
    /**
     * Gets an error summary for a proxy rule.
     */
    suspend fun getErrorSummary(ruleId: String, period: String): ProxyErrorSummary = withContext(Dispatchers.IO) {
        val queue = proxyErrors[ruleId] ?: return@withContext ProxyErrorSummary(
            ruleId = ruleId,
            totalErrors = 0,
            errorsByType = emptyMap(),
            errorsByStatusCode = emptyMap(),
            errorRate = 0.0,
            period = period,
            topErrorPaths = emptyList(),
            topErrorClients = emptyList()
        )
        
        val now = System.currentTimeMillis()
        val timeWindow = when (period) {
            "last_hour" -> 60 * 60 * 1000L
            "last_day" -> 24 * 60 * 60 * 1000L
            "last_week" -> 7 * 24 * 60 * 60 * 1000L
            else -> 60 * 60 * 1000L // Default to last hour
        }
        
        val filteredErrors = queue.filter { now - it.timestamp <= timeWindow }
        
        if (filteredErrors.isEmpty()) {
            return@withContext ProxyErrorSummary(
                ruleId = ruleId,
                totalErrors = 0,
                errorsByType = emptyMap(),
                errorsByStatusCode = emptyMap(),
                errorRate = 0.0,
                period = period,
                topErrorPaths = emptyList(),
                topErrorClients = emptyList()
            )
        }
        
        val totalErrors = filteredErrors.size.toLong()
        
        // Get traffic data for the same period to calculate error rate
        val trafficQueue = trafficData[ruleId]
        val filteredTraffic = trafficQueue?.filter { now - it.timestamp <= timeWindow } ?: emptyList()
        val totalRequests = filteredTraffic.sumOf { it.requestCount }
        
        val errorRate = if (totalRequests > 0) totalErrors.toDouble() / totalRequests else 0.0
        
        // Aggregate errors by type
        val errorsByType = filteredErrors
            .groupBy { it.errorType }
            .mapValues { it.value.size.toLong() }
        
        // Aggregate errors by status code
        val errorsByStatusCode = filteredErrors
            .filter { it.statusCode != null }
            .groupBy { it.statusCode!! }
            .mapValues { it.value.size.toLong() }
        
        // Aggregate errors by path
        val errorsByPath = filteredErrors
            .filter { it.path != null }
            .groupBy { it.path!! }
            .mapValues { it.value.size.toLong() }
            .toList()
            .sortedByDescending { it.second }
            .take(10)
        
        // Aggregate errors by client IP
        val errorsByClient = filteredErrors
            .filter { it.clientIp != null }
            .groupBy { it.clientIp!! }
            .mapValues { it.value.size.toLong() }
            .toList()
            .sortedByDescending { it.second }
            .take(10)
        
        return@withContext ProxyErrorSummary(
            ruleId = ruleId,
            totalErrors = totalErrors,
            errorsByType = errorsByType,
            errorsByStatusCode = errorsByStatusCode,
            errorRate = errorRate,
            period = period,
            topErrorPaths = errorsByPath,
            topErrorClients = errorsByClient
        )
    }
    
    /**
     * Records a request/response log entry.
     */
    suspend fun recordRequestLog(log: RequestResponseLog) = withContext(Dispatchers.IO) {
        val queue = requestLogs.computeIfAbsent(log.ruleId) { ConcurrentLinkedQueue() }
        
        // Add the new log entry
        queue.add(log)
        
        // Trim the queue if it exceeds the maximum size
        while (queue.size > maxLogEntries) {
            queue.poll()
        }
        
        // Emit the log entry to the shared flow
        _logUpdates.emit(log)
    }
    
    /**
     * Gets request logs for a proxy rule.
     */
    suspend fun getRequestLogs(ruleId: String, limit: Int = 100): List<RequestResponseLog> = withContext(Dispatchers.IO) {
        val queue = requestLogs[ruleId] ?: return@withContext emptyList()
        return@withContext queue.toList().takeLast(limit)
    }
    
    /**
     * Searches request logs for a proxy rule.
     */
    suspend fun searchRequestLogs(
        ruleId: String,
        clientIp: String? = null,
        method: String? = null,
        path: String? = null,
        statusCode: Int? = null,
        minResponseTime: Double? = null,
        maxResponseTime: Double? = null,
        startTime: Long? = null,
        endTime: Long? = null,
        limit: Int = 100
    ): List<RequestResponseLog> = withContext(Dispatchers.IO) {
        val queue = requestLogs[ruleId] ?: return@withContext emptyList()
        
        return@withContext queue.filter { log ->
            (clientIp == null || log.clientIp == clientIp) &&
            (method == null || log.method == method) &&
            (path == null || log.path.contains(path)) &&
            (statusCode == null || log.statusCode == statusCode) &&
            (minResponseTime == null || log.responseTime >= minResponseTime) &&
            (maxResponseTime == null || log.responseTime <= maxResponseTime) &&
            (startTime == null || log.timestamp >= startTime) &&
            (endTime == null || log.timestamp <= endTime)
        }.takeLast(limit)
    }
    
    /**
     * Creates an error alert configuration.
     */
    suspend fun createAlertConfig(config: ErrorAlertConfig): ErrorAlertConfig = withContext(Dispatchers.IO) {
        val newConfig = config.copy(
            id = config.id.ifEmpty { UUID.randomUUID().toString() }
        )
        alertConfigs[newConfig.id] = newConfig
        newConfig
    }
    
    /**
     * Gets all error alert configurations.
     */
    suspend fun getAlertConfigs(): List<ErrorAlertConfig> = withContext(Dispatchers.IO) {
        alertConfigs.values.toList()
    }
    
    /**
     * Gets an error alert configuration by ID.
     */
    suspend fun getAlertConfig(id: String): ErrorAlertConfig? = withContext(Dispatchers.IO) {
        alertConfigs[id]
    }
    
    /**
     * Updates an error alert configuration.
     */
    suspend fun updateAlertConfig(id: String, config: ErrorAlertConfig): ErrorAlertConfig? = withContext(Dispatchers.IO) {
        if (!alertConfigs.containsKey(id)) return@withContext null
        
        val updatedConfig = config.copy(id = id)
        alertConfigs[id] = updatedConfig
        updatedConfig
    }
    
    /**
     * Deletes an error alert configuration.
     */
    suspend fun deleteAlertConfig(id: String): Boolean = withContext(Dispatchers.IO) {
        alertConfigs.remove(id) != null
    }
    
    /**
     * Gets all active alerts.
     */
    suspend fun getActiveAlerts(): List<ErrorAlert> = withContext(Dispatchers.IO) {
        activeAlerts.values.toList()
    }
    
    /**
     * Acknowledges an alert.
     */
    suspend fun acknowledgeAlert(id: String, acknowledgedBy: String): ErrorAlert? = withContext(Dispatchers.IO) {
        val alert = activeAlerts[id] ?: return@withContext null
        
        val updatedAlert = alert.copy(
            status = AlertStatus.ACKNOWLEDGED,
            acknowledgedAt = System.currentTimeMillis(),
            acknowledgedBy = acknowledgedBy
        )
        
        activeAlerts[id] = updatedAlert
        _alertUpdates.emit(updatedAlert)
        
        updatedAlert
    }
    
    /**
     * Resolves an alert.
     */
    suspend fun resolveAlert(id: String): ErrorAlert? = withContext(Dispatchers.IO) {
        val alert = activeAlerts[id] ?: return@withContext null
        
        val updatedAlert = alert.copy(
            status = AlertStatus.RESOLVED,
            resolvedAt = System.currentTimeMillis()
        )
        
        activeAlerts.remove(id)
        _alertUpdates.emit(updatedAlert)
        
        updatedAlert
    }
    
    /**
     * Checks if an error should trigger any alerts.
     */
    private suspend fun checkErrorAlerts(error: ProxyError) {
        val now = System.currentTimeMillis()
        
        // Get applicable alert configurations
        val applicableConfigs = alertConfigs.values.filter { config ->
            config.enabled &&
            (config.ruleId == null || config.ruleId == error.ruleId) &&
            (config.errorType == null || config.errorType == error.errorType) &&
            (config.statusCode == null || (error.statusCode != null && config.statusCode == error.statusCode))
        }
        
        for (config in applicableConfigs) {
            // Calculate error rate for the time window
            val timeWindow = config.timeWindow
            val startTime = now - timeWindow
            
            val errorQueue = proxyErrors[error.ruleId] ?: continue
            val recentErrors = errorQueue.filter { it.timestamp >= startTime }.size
            
            // Get traffic data for the same period
            val trafficQueue = trafficData[error.ruleId] ?: continue
            val recentTraffic = trafficQueue.filter { it.timestamp >= startTime }
            val recentRequests = recentTraffic.sumOf { it.requestCount }
            
            // Skip if there aren't enough requests to consider
            if (recentRequests < config.minRequests) continue
            
            val errorRate = recentErrors.toDouble() / recentRequests
            
            // Check if the error rate exceeds the threshold
            if (errorRate >= config.threshold) {
                // Create an alert if one doesn't already exist for this config
                val alertId = "${config.id}_${error.ruleId}"
                
                if (!activeAlerts.containsKey(alertId)) {
                    val alert = ErrorAlert(
                        id = alertId,
                        configId = config.id,
                        ruleId = error.ruleId,
                        timestamp = now,
                        errorRate = errorRate,
                        errorCount = recentErrors.toLong(),
                        requestCount = recentRequests,
                        message = "Error rate of ${String.format("%.2f", errorRate * 100)}% exceeds threshold of ${String.format("%.2f", config.threshold * 100)}% (${recentErrors} errors in ${recentRequests} requests)",
                        status = AlertStatus.ACTIVE
                    )
                    
                    activeAlerts[alertId] = alert
                    _alertUpdates.emit(alert)
                    
                    // In a real implementation, we would send notifications here
                    // based on the notification channels configured
                }
            }
        }
    }
    
    /**
     * Exports proxy rules to a file in the specified format.
     *
     * @param filePath Path to the export file
     * @param format Export format (json or yaml)
     * @param ruleIds Optional list of rule IDs to export (if null, exports all rules)
     * @return true if the export was successful
     */
    suspend fun exportRules(filePath: String, format: String, ruleIds: List<String>? = null): Boolean = withContext(Dispatchers.IO) {
        try {
            val rulesToExport = if (ruleIds != null) {
                proxyRules.values.filter { it.id in ruleIds }
            } else {
                proxyRules.values.toList()
            }
            
            if (rulesToExport.isEmpty()) {
                return@withContext false
            }
            
            val file = File(filePath)
            file.parentFile?.mkdirs()
            
            when (format.lowercase()) {
                "json" -> {
                    val json = Json {
                        prettyPrint = true
                        encodeDefaults = true
                    }
                    file.writeText(json.encodeToString(rulesToExport))
                }
                "yaml" -> {
                    val options = DumperOptions()
                    options.defaultFlowStyle = DumperOptions.FlowStyle.BLOCK
                    options.isPrettyFlow = true
                    
                    val yamlSerializer = Yaml(options)
                    
                    // Convert rules to maps for YAML serialization
                    val rulesAsMaps = rulesToExport.map { rule ->
                        mapOf(
                            "id" to rule.id,
                            "name" to rule.name,
                            "sourceHost" to rule.sourceHost,
                            "sourcePath" to rule.sourcePath,
                            "targetContainer" to rule.targetContainer,
                            "targetPort" to rule.targetPort,
                            "protocol" to rule.protocol.toString(),
                            "sslEnabled" to rule.sslEnabled,
                            "sslCertPath" to rule.sslCertPath,
                            "sslKeyPath" to rule.sslKeyPath,
                            "headers" to rule.headers,
                            "responseHeaders" to rule.responseHeaders,
                            "healthCheck" to rule.healthCheck?.let { hc ->
                                mapOf(
                                    "path" to hc.path,
                                    "interval" to hc.interval,
                                    "timeout" to hc.timeout,
                                    "retries" to hc.retries,
                                    "successCodes" to hc.successCodes
                                )
                            },
                            "loadBalancing" to rule.loadBalancing?.let { lb ->
                                mapOf(
                                    "method" to lb.method.toString(),
                                    "targets" to lb.targets.map { target ->
                                        mapOf(
                                            "container" to target.container,
                                            "port" to target.port,
                                            "weight" to target.weight
                                        )
                                    },
                                    "sticky" to lb.sticky,
                                    "cookieName" to lb.cookieName,
                                    "cookieExpiry" to lb.cookieExpiry
                                )
                            },
                            "advancedConfig" to rule.advancedConfig?.let { ac ->
                                mapOf(
                                    "clientMaxBodySize" to ac.clientMaxBodySize,
                                    "proxyConnectTimeout" to ac.proxyConnectTimeout,
                                    "proxySendTimeout" to ac.proxySendTimeout,
                                    "proxyReadTimeout" to ac.proxyReadTimeout,
                                    "proxyBufferSize" to ac.proxyBufferSize,
                                    "proxyBuffers" to ac.proxyBuffers,
                                    "proxyBusyBuffersSize" to ac.proxyBusyBuffersSize,
                                    "cacheEnabled" to ac.cacheEnabled,
                                    "cacheDuration" to ac.cacheDuration,
                                    "corsEnabled" to ac.corsEnabled,
                                    "corsAllowOrigin" to ac.corsAllowOrigin,
                                    "corsAllowMethods" to ac.corsAllowMethods,
                                    "corsAllowHeaders" to ac.corsAllowHeaders,
                                    "corsAllowCredentials" to ac.corsAllowCredentials,
                                    "rateLimit" to ac.rateLimit?.let { rl ->
                                        mapOf(
                                            "requestsPerSecond" to rl.requestsPerSecond,
                                            "burstSize" to rl.burstSize,
                                            "nodelay" to rl.nodelay
                                        )
                                    },
                                    "rewriteRules" to ac.rewriteRules.map { rr ->
                                        mapOf(
                                            "pattern" to rr.pattern,
                                            "replacement" to rr.replacement,
                                            "flag" to rr.flag
                                        )
                                    }
                                )
                            },
                            "customNginxConfig" to rule.customNginxConfig,
                            "created" to rule.created,
                            "enabled" to rule.enabled
                        )
                    }
                    
                    file.writeText(yamlSerializer.dump(rulesAsMaps))
                }
                else -> {
                    return@withContext false
                }
            }
            
            true
        } catch (e: Exception) {
            false
        }
    }
    
    /**
     * Imports proxy rules from a file.
     *
     * @param filePath Path to the import file
     * @param format Import format (json or yaml)
     * @param overwriteExisting Whether to overwrite existing rules with the same ID
     * @return Number of rules imported
     */
    suspend fun importRules(filePath: String, format: String, overwriteExisting: Boolean = false): Int = withContext(Dispatchers.IO) {
        try {
            val file = File(filePath)
            if (!file.exists() || !file.isFile) {
                return@withContext 0
            }
            
            val content = file.readText()
            if (content.isBlank()) {
                return@withContext 0
            }
            
            val importedRules = when (format.lowercase()) {
                "json" -> {
                    val json = Json {
                        ignoreUnknownKeys = true
                        isLenient = true
                    }
                    json.decodeFromString<List<ProxyRule>>(content)
                }
                "yaml" -> {
                    val yamlParser = Yaml()
                    @Suppress("UNCHECKED_CAST")
                    val rulesAsMaps = yamlParser.load<Any>(content) as List<Map<String, Any>>
                    
                    rulesAsMaps.mapNotNull { ruleMap ->
                        try {
                            // Convert YAML map to ProxyRule
                            ProxyRule(
                                id = ruleMap["id"] as? String ?: UUID.randomUUID().toString(),
                                name = ruleMap["name"] as? String ?: "",
                                sourceHost = ruleMap["sourceHost"] as? String ?: "",
                                sourcePath = ruleMap["sourcePath"] as? String ?: "/",
                                targetContainer = ruleMap["targetContainer"] as? String ?: "",
                                targetPort = (ruleMap["targetPort"] as? Int) ?: 80,
                                protocol = try {
                                    ProxyProtocol.valueOf(ruleMap["protocol"] as? String ?: "HTTP")
                                } catch (e: Exception) {
                                    ProxyProtocol.HTTP
                                },
                                sslEnabled = ruleMap["sslEnabled"] as? Boolean ?: false,
                                sslCertPath = ruleMap["sslCertPath"] as? String,
                                sslKeyPath = ruleMap["sslKeyPath"] as? String,
                                headers = (ruleMap["headers"] as? Map<String, String>) ?: emptyMap(),
                                responseHeaders = (ruleMap["responseHeaders"] as? Map<String, String>) ?: emptyMap(),
                                healthCheck = (ruleMap["healthCheck"] as? Map<String, Any>)?.let { hcMap ->
                                    HealthCheck(
                                        path = hcMap["path"] as? String ?: "/health",
                                        interval = (hcMap["interval"] as? Int) ?: 30,
                                        timeout = (hcMap["timeout"] as? Int) ?: 5,
                                        retries = (hcMap["retries"] as? Int) ?: 3,
                                        successCodes = hcMap["successCodes"] as? String ?: "200-399"
                                    )
                                },
                                loadBalancing = (ruleMap["loadBalancing"] as? Map<String, Any>)?.let { lbMap ->
                                    LoadBalancingConfig(
                                        method = try {
                                            LoadBalancingMethod.valueOf(lbMap["method"] as? String ?: "ROUND_ROBIN")
                                        } catch (e: Exception) {
                                            LoadBalancingMethod.ROUND_ROBIN
                                        },
                                        targets = (lbMap["targets"] as? List<Map<String, Any>>)?.map { targetMap ->
                                            LoadBalancingTarget(
                                                container = targetMap["container"] as? String ?: "",
                                                port = (targetMap["port"] as? Int) ?: 80,
                                                weight = (targetMap["weight"] as? Int) ?: 1
                                            )
                                        } ?: emptyList(),
                                        sticky = lbMap["sticky"] as? Boolean ?: false,
                                        cookieName = lbMap["cookieName"] as? String,
                                        cookieExpiry = lbMap["cookieExpiry"] as? Int
                                    )
                                },
                                advancedConfig = (ruleMap["advancedConfig"] as? Map<String, Any>)?.let { acMap ->
                                    AdvancedProxyConfig(
                                        clientMaxBodySize = acMap["clientMaxBodySize"] as? String,
                                        proxyConnectTimeout = (acMap["proxyConnectTimeout"] as? Int) ?: 60,
                                        proxySendTimeout = (acMap["proxySendTimeout"] as? Int) ?: 60,
                                        proxyReadTimeout = (acMap["proxyReadTimeout"] as? Int) ?: 60,
                                        proxyBufferSize = acMap["proxyBufferSize"] as? String,
                                        proxyBuffers = acMap["proxyBuffers"] as? String,
                                        proxyBusyBuffersSize = acMap["proxyBusyBuffersSize"] as? String,
                                        cacheEnabled = acMap["cacheEnabled"] as? Boolean ?: false,
                                        cacheDuration = acMap["cacheDuration"] as? String,
                                        corsEnabled = acMap["corsEnabled"] as? Boolean ?: false,
                                        corsAllowOrigin = acMap["corsAllowOrigin"] as? String,
                                        corsAllowMethods = acMap["corsAllowMethods"] as? String,
                                        corsAllowHeaders = acMap["corsAllowHeaders"] as? String,
                                        corsAllowCredentials = acMap["corsAllowCredentials"] as? Boolean ?: false,
                                        rateLimit = (acMap["rateLimit"] as? Map<String, Any>)?.let { rlMap ->
                                            RateLimitConfig(
                                                requestsPerSecond = (rlMap["requestsPerSecond"] as? Int) ?: 10,
                                                burstSize = (rlMap["burstSize"] as? Int) ?: 5,
                                                nodelay = rlMap["nodelay"] as? Boolean ?: false
                                            )
                                        },
                                        rewriteRules = (acMap["rewriteRules"] as? List<Map<String, Any>>)?.map { rrMap ->
                                            RewriteRule(
                                                pattern = rrMap["pattern"] as? String ?: "",
                                                replacement = rrMap["replacement"] as? String ?: "",
                                                flag = rrMap["flag"] as? String ?: "last"
                                            )
                                        } ?: emptyList()
                                    )
                                },
                                customNginxConfig = ruleMap["customNginxConfig"] as? String,
                                created = (ruleMap["created"] as? Long) ?: System.currentTimeMillis(),
                                enabled = ruleMap["enabled"] as? Boolean ?: true
                            )
                        } catch (e: Exception) {
                            null
                        }
                    }
                }
                else -> {
                    return@withContext 0
                }
            }
            
            var importCount = 0
            
            for (rule in importedRules) {
                val existingRule = proxyRules[rule.id]
                
                if (existingRule == null || overwriteExisting) {
                    proxyRules[rule.id] = rule
                    importCount++
                }
            }
            
            if (importCount > 0) {
                updateNginxConfig()
            }
            
            importCount
        } catch (e: Exception) {
            0
        }
    }
}